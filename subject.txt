1. i filosofi devono a turno mangiare, dormire, pensare. 
	Quando svolgono una mansione, non possono svolgere le altre

2. Ci sono tante forchette quanti filosofi 

3. Per mangiare, il filosofo deve bloccare ( mutare ) due forchette
	una a destra e l'altra a sinistra: quindi fork N -1 e fork N + 1, tranne 
	che per il primo: lui prendera N + 1 e fork dell ultimo filosofo

4. routine di un filosofo: eating > UNMUTANO FORKS > dormono x time to sleep > pensano per time to think > bloccano 2 fork > mangiano

5. Se non si mangia entro time to die > muoiono e si ferma la simulazione

6. INPUT: n filosofi ( e d forchette ) - time to die (tempo entro il quale un filosofo deve mangiare, altrimenti muore )
			time to eat ( per quanto tempo mutano le fork e quindi mangiano ) time to sleep ( per quanto tempo dormono )
			n di pasti ( opzionale, se tutti i filosofi hanno mangiato almeno n pasti, la simulazione si stoppa )

7. i filosofi hanno un ID da 1 a N 

8. il filosofo n 1 siede vicino a filosofo 2 e filosofo N. Tutti gli altri siedono vicino a N -1 e N+1

9 STAMPA: 

◦ timestamp_in_ms X has taken a fork
◦ timestamp_in_ms X is eating
◦ timestamp_in_ms X is sleeping
◦ timestamp_in_ms X is thinking
◦ timestamp_in_ms X died

10. i messaggi stampati non devono sovrapporsi ( mutex stampa )
11. la morte di un filosofo deve essere annunciata entro 10 ms dalla morte

12. ogni filosofo e un thread 
13. ogni forchetta e protetta da un mutex 

FUNZIONI AMMESSE:

memset - string.h - void *memset(void *dest, int c, size_t count) - imposta la memoria di dest a c
printf - stdio.h 
malloc - stdlib.h
free - stdlib.h
write - unistd.h

usleep - unistd.h - int usleep(useconds_t usec) - suspends execution of the calling thread for (at least) usec microseconds
gettimeofday - unistd.h / sys/time.h - int gettimeofday(struct timeval *, struct tzp *); - The gettimeofday() function fills two structures with details about the current time of day - ti da il tempo attuale in ms

THREAD: 

pthread_create - pthread.h - int pthread_create(pthread_t *restrict tid, const pthread_attr_t  *restrict tattr, void*(*start_routine)(void *), void *restrict arg) - pointer al thread, attributo del thread, pointer a funzione, eventuali parametri da passare alla funzione
pthread_detach - pthread.h - int pthread_detach(pthread_t tid) - is used to indicate to your application that storage for the thread tid can be reclaimed when the thread terminates. Threads should be detached when they are no longer needed. If tid has not terminated, pthread_detach() does not cause the thread to terminate.
pthread_join - pthread.h - int pthread_join(pthread_t tid, void **status) - si passa la struct e un puntatore in cui salvare il ritorno

MUTEX: 

pthread_mutex_init - pthread.h - int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr) - crea (inizializza) un mutex.
pthread_mutex_destroy - pthread.h -  int pthread_mutex_destroy(pthread_mutex_t *mutex) - distrugge il mutex quando non serve più.
pthread_mutex_lock - pthread.h - int pthread_mutex_lock(pthread_mutex_t *mutex) - blocca un mutex 
pthread_mutex_unlock - pthread.h - int pthread_mutex_unlock(pthread_mutex_t *mutex) - sblocca un mutex

NO LIBFT

CONSIDERAZIONI SPARSE:

funzione per unmutare le fork nella struttura del filosofo N

dal momento in cui viene creato il thread, si hanno time to die ms per entrare nello stato di eating (tempo complessivo tra sleep e think). Il tempo si resetta quando mangia e riparte quando ha iniziato a pensare




Fase 2 — Parsing e inizializzazione
Obiettivo: leggere input e allocare strutture.

funzione init_table() per:

OK Validare argomenti

OK Salvare i valori nella struct

OK Allocare i fork mutex

Inizializzare write_mutex

Allocare philo[i] e assegnare id, forchette, etc.

🚥 Inizializza tutti i mutex con pthread_mutex_init

🧵 Fase 3 — Creazione dei thread
Obiettivo: lanciare i thread correttamente

K Ogni filosofo è un thread:

OK Usa pthread_create(&philo->thread, ..., routine, philo)

OK Fai join su ogni thread

Verifica che ogni thread funzioni stampando “filosofo X inizia a mangiare”

🍽 Fase 4 — Routine dei filosofi
Obiettivo: implementare routine()

Passi da seguire nella routine:

Prendere forche (lock)

Stampare “ha preso una forchetta”

Mangiare (aggiorna last_meal, sleep)

Lasciare le forche (unlock)

Dormire

Pensare

Usa get_time() per calcolare tempo da start_time

Usa usleep() o custom sleep per controllo più preciso

🧠 Fase 5 — Monitor di morte
Obiettivo: thread che controlla se qualcuno muore

Crea un thread separato o funzione nel main:

Loop che ogni 1ms controlla:

c
Copy
Edit
get_time() - philo[i]->last_meal > time_to_die
Se sì:

Stampi “X died”

Blocchi tutto (table->died = 1)

Sblocchi eventuali mutex

Blocca la stampa con write_mutex per evitare sovrapposizioni

🧹 Fase 6 — Fine programma e free
Obiettivo: liberare memoria e distruggere mutex

pthread_mutex_destroy su ogni fork

free(philo[i])

free(philos), free(forks)

Distruggi anche write_mutex

✅ Fase 7 — Check dei requisiti
Obiettivo: conformità totale alle regole del soggetto

Nessun filosofo deve morire se non deve

Nessun filosofo mangia due volte senza lasciare la forchetta

Nessun output deve essere spezzato o misto

Nessun memory leak

Bonus: se hai il flag must_eat, termina dopo che tutti hanno mangiato N volte

